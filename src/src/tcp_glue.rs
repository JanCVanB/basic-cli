// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

type Op_StderrWrite = roc_std::RocStr;
type Op_StdoutWrite = roc_std::RocStr;
type TODO_roc_function_69 = roc_std::RocStr;
type TODO_roc_function_70 = roc_std::RocStr;

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
#[derive(Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct U1 ();


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]

#[repr(C)]
pub struct RocFunction_93 {
    pub closure_data: roc_std::RocList<u8>,
}

impl RocFunction_93 {
    pub fn force_thunk(mut self, arg_0: ()) -> U1 {
        extern "C" {
             fn roc__mainForHost_0_caller(arg_0: &(), closure_data: *mut u8, output: *mut U1);
        }

        let mut output = std::mem::MaybeUninit::uninit();
        let ptr = self.closure_data.as_mut_ptr();
        unsafe { roc__mainForHost_0_caller(&arg_0, ptr, output.as_mut_ptr()) };
        unsafe { output.assume_init() }
    }
}

impl U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named Err, which has no payload.
        pub const Err: Self = Self();

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Err tag
        /// has no payload, this does nothing and is only here for completeness.
        pub fn into_Err(self) {
            ()
        }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Err tag
        /// has no payload, this does nothing and is only here for completeness.
        pub fn as_Err(&self) {
            ()
        }
}

impl core::fmt::Debug for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {f.write_str("U1::Err")    }

}
